// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countReplies = `-- name: CountReplies :one
SELECT COUNT(*) FROM replies 
WHERE thread_id = ?
`

func (q *Queries) CountReplies(ctx context.Context, threadID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countReplies, threadID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countThreads = `-- name: CountThreads :one
SELECT COUNT(*) FROM threads
`

func (q *Queries) CountThreads(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countThreads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReply = `-- name: CreateReply :execresult
INSERT INTO replies(comment, date, thread_id)
VALUES (?, ?, ?)
`

type CreateReplyParams struct {
	Comment  string
	Date     string
	ThreadID int32
}

func (q *Queries) CreateReply(ctx context.Context, arg CreateReplyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createReply, arg.Comment, arg.Date, arg.ThreadID)
}

const createThread = `-- name: CreateThread :execresult
INSERT INTO threads(title, comment, date, board_id)
VALUES (?, ?, ?, ?)
`

type CreateThreadParams struct {
	Title   string
	Comment string
	Date    string
	BoardID int32
}

func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createThread,
		arg.Title,
		arg.Comment,
		arg.Date,
		arg.BoardID,
	)
}

const deleteThread = `-- name: DeleteThread :execresult
DELETE FROM threads
WHERE thread_id = ?
`

func (q *Queries) DeleteThread(ctx context.Context, threadID int32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteThread, threadID)
}

const getBoardThreads = `-- name: GetBoardThreads :many
SELECT thread_id, title, comment, date, board_id FROM threads
WHERE board_id = ?
ORDER BY date ASC
`

func (q *Queries) GetBoardThreads(ctx context.Context, boardID int32) ([]Thread, error) {
	rows, err := q.db.QueryContext(ctx, getBoardThreads, boardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ThreadID,
			&i.Title,
			&i.Comment,
			&i.Date,
			&i.BoardID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldestThread = `-- name: GetOldestThread :one
SELECT thread_id, title, comment, date, board_id FROM threads 
WHERE board_id = ?
ORDER BY date ASC
LIMIT 1
`

func (q *Queries) GetOldestThread(ctx context.Context, boardID int32) (Thread, error) {
	row := q.db.QueryRowContext(ctx, getOldestThread, boardID)
	var i Thread
	err := row.Scan(
		&i.ThreadID,
		&i.Title,
		&i.Comment,
		&i.Date,
		&i.BoardID,
	)
	return i, err
}

const getThread = `-- name: GetThread :one
SELECT thread_id, title, comment, date, board_id FROM threads
WHERE thread_id = ?
LIMIT 1
`

func (q *Queries) GetThread(ctx context.Context, threadID int32) (Thread, error) {
	row := q.db.QueryRowContext(ctx, getThread, threadID)
	var i Thread
	err := row.Scan(
		&i.ThreadID,
		&i.Title,
		&i.Comment,
		&i.Date,
		&i.BoardID,
	)
	return i, err
}

const getThreadReplies = `-- name: GetThreadReplies :many
SELECT reply_id, comment, date, thread_id FROM replies
WHERE thread_id = ?
ORDER BY date ASC
`

func (q *Queries) GetThreadReplies(ctx context.Context, threadID int32) ([]Reply, error) {
	rows, err := q.db.QueryContext(ctx, getThreadReplies, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reply
	for rows.Next() {
		var i Reply
		if err := rows.Scan(
			&i.ReplyID,
			&i.Comment,
			&i.Date,
			&i.ThreadID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreads = `-- name: GetThreads :many
SELECT thread_id, title, comment, date, board_id FROM threads
ORDER BY date ASC
LIMIT ?
`

func (q *Queries) GetThreads(ctx context.Context, limit int32) ([]Thread, error) {
	rows, err := q.db.QueryContext(ctx, getThreads, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Thread
	for rows.Next() {
		var i Thread
		if err := rows.Scan(
			&i.ThreadID,
			&i.Title,
			&i.Comment,
			&i.Date,
			&i.BoardID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
